<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="description" content="设计者模式——2 结构型模式概述篇"><meta name="keywords" content="java,设计者模式"><meta name="author" content="冰不良"><meta name="copyright" content="冰不良"><meta name="theme-color" content="#6200ee"><title>设计者模式——2 结构型模式概述篇 | 冰不良のblog</title><link rel="shortcut icon" href="/yun.svg"><link rel="mask-icon" href="/yun.svg" color="#6200ee"><link rel="preload" href="/css/hexo-theme-yun.css" as="style"><link rel="preload" href="/js/hexo-theme-yun.js" as="script"><link rel="prefetch" href="/js/sidebar.js" as="script"><link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin><link rel="stylesheet" href="/css/hexo-theme-yun.css"><script id="yun-config">
    window.CONFIG = {"root":"/","title":"冰不良の小站","version":"0.7.1","anonymous_image":"https://cdn.jsdelivr.net/gh/YunYouJun/cdn/img/avatar/none.jpg","say":{"api":"https://v1.hitokoto.cn","hitokoto":true},"algolia":{"appID":"5WNMZVZKKS","apiKey":"b66222e466f2046a9accd67fc9fcbe08","indexName":"hexo","hits":{"per_page":8},"labels":{"input_placeholder":"搜索文章","hits_empty":"找不到您查询的内容: ${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},"fireworks":{"colors":["102, 167, 221","62, 131, 225","33, 78, 194"]}};
  </script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" defer></script><script src="/js/load-aplayer.js" defer></script><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@900&amp;display=swap" media="none" onload="this.media='all'"><script src="//at.alicdn.com/t/font_1140697_rtqh36oinzl.js" async></script><link rel="preconnect" href="https://www.google-analytics.com" crossorigin><link rel="preconnect" href="https://stats.g.doubleclick.net" crossorigin><script async src="https://www.googletagmanager.com/gtag/js?id=UA-7FZJ6MEGB5-G"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-7FZJ6MEGB5-G');</script><script>(function(){
  var bp = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  if (curProtocol === 'https') {
    bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
  }
  else {
    bp.src = 'http://push.zhanzhang.baidu.com/push.js';
  }
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(bp, s);
})();</script><script src="https://cdn.jsdelivr.net/npm/pjax@latest/pjax.min.js" defer></script><script src="/js/pjax.js" defer></script><div class="js-Pjax"></div><meta name="generator" content="Hexo 6.3.0"><link rel="stylesheet" href="/css/prism.css" type="text/css"></head><body><script defer src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script defer src="/js/ui/fireworks.js"></script><canvas class="fireworks"></canvas><canvas id="trianglify"></canvas><script defer src="https://cdn.jsdelivr.net/npm/trianglify@latest/dist/trianglify.min.js"></script><script>document.addEventListener("DOMContentLoaded", () => {
  const pattern = Trianglify({
    width: 800,
    height: 600,
    cell_size: 75,
    palette: ["YlGnBu", "GnBu", "Purples", "Blues"],
  });
  document.body.appendChild(pattern.canvas(trianglify));
});</script><div class="container"><a class="sidebar-toggle sidebar-toggle-fixed hty-icon-button"><div class="hamburger hamburger--spin" type="button"><span class="hamburger-box"><span class="hamburger-inner"></span></span></div></a><aside class="sidebar"><script defer src="/js/sidebar.js"></script><ul class="sidebar-nav"><li class="sidebar-nav-item sidebar-nav-toc hty-icon-button sidebar-nav-active" data-target="post-toc-wrap" title="文章目录"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-list-ordered"></use></svg></li><li class="sidebar-nav-item sidebar-nav-overview hty-icon-button" data-target="site-overview-wrap" title="站点概览"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-passport-line"></use></svg></li></ul><div class="sidebar-panel" id="site-overview-wrap"><div class="site-info fix-top"><a class="site-author-avatar" href="/about" title="冰不良"><img width="96" loading="lazy" src="/images/%E5%A4%B4%E5%83%8F.jpg" alt="冰不良"></a><div class="site-author-name"><a href="/about/">冰不良</a></div><a class="site-name" href="/about/site.html">冰不良のblog</a><sub class="site-subtitle"></sub><div class="site-desciption">快来和我一起秃头吧！</div></div><nav class="site-state"><a class="site-state-item hty-icon-button icon-home" href="/" title="我的主页"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-home-4-line"></use></svg></span></a><div class="site-state-item site-state-posts"><a href="/archives" title="归档"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-archive-line"></use></svg></span><span class="site-state-item-count">17</span></a></div><div class="site-state-item site-state-tags"><a href="/tags" title="标签"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-price-tag-3-line"></use></svg></span><span class="site-state-item-count">14</span></a></div><a class="site-state-item hty-icon-button" href="/about/#comment" title="留言板"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-clipboard-line"></use></svg></span></a></nav><hr style="margin-bottom:0.5rem"><div class="links-of-author"><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://wpa.qq.com/msgrd?v=3&amp;uin=2330181012&amp;site=qq&amp;menu=yes" title="QQ" target="_blank" style="color:#12B7F5"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-qq-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://github.com/BingBuLiang" title="GitHub" target="_blank" style="color:#181717"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-github-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="mailto:bingbuliang996@163.com" title="E-Mail" target="_blank" style="color:#8E71C1"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-mail-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://weibo.com/u/5648709252" title="微博" target="_blank" style="color:#E6162D"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-weibo-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://music.163.com/" title="网易云音乐" target="_blank" style="color:#C10D0C"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-netease-cloud-music-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://www.zhihu.com/people/bing-bu-liang-xian-sen?utm_id=0" title="知乎" target="_blank" style="color:#0084FF"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-zhihu-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://space.bilibili.com/470508529" title="哔哩哔哩" target="_blank" style="color:#FF8EB3"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-bilibili-line"></use></svg></a></div><hr style="margin:0.5rem 1rem"><div class="links"><a class="links-item hty-icon-button" href="/links/" title="我的小伙伴们" style="color:dodgerblue"><i class="ri:genderless-line"></i></a></div></div><div class="sidebar-panel sidebar-panel-active" id="post-toc-wrap"><div class="post-toc"><div class="post-toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F-7"><span class="toc-number">1.</span> <span class="toc-text">结构型模式  7</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E4%BD%9C%E7%94%A8"><span class="toc-number">1.0.1.</span> <span class="toc-text">核心作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B1%87%E6%80%BB"><span class="toc-number">1.0.2.</span> <span class="toc-text">汇总</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F-adapter"><span class="toc-number">1.1.</span> <span class="toc-text">适配器模式 adapter</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.1.1.</span> <span class="toc-text">什么是适配器模式?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E4%B8%AD%E7%9A%84%E8%A7%92%E8%89%B2"><span class="toc-number">1.1.2.</span> <span class="toc-text">模式中的角色</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E4%B8%AD%E7%9A%84%E5%9C%BA%E6%99%AF"><span class="toc-number">1.1.3.</span> <span class="toc-text">工作中的场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%A6%E4%B9%A0%E4%B8%AD%E8%A7%81%E8%BF%87%E7%9A%84%E5%9C%BA%E6%99%AF"><span class="toc-number">1.1.4.</span> <span class="toc-text">学习中见过的场景</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F-Proxy-pattern"><span class="toc-number">1.2.</span> <span class="toc-text">代理模式  Proxy pattern</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E4%BD%9C%E7%94%A8-1"><span class="toc-number">1.2.1.</span> <span class="toc-text">核心作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E8%A7%92%E8%89%B2"><span class="toc-number">1.2.2.</span> <span class="toc-text">核心角色</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">1.2.3.</span> <span class="toc-text">应用场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6%E4%B8%AD%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9A"><span class="toc-number">1.2.4.</span> <span class="toc-text">开发框架中应用场景：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E7%B1%BB"><span class="toc-number">1.2.5.</span> <span class="toc-text">分类</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E7%9B%B8%E6%AF%94%E4%BA%8E%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86%E7%9A%84%E4%BC%98%E7%82%B9"><span class="toc-number">1.2.5.1.</span> <span class="toc-text">动态代理相比于静态代理的优点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#JDK%E8%87%AA%E5%B8%A6%E7%9A%84%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86"><span class="toc-number">1.2.5.2.</span> <span class="toc-text">JDK自带的动态代理</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.2.6.</span> <span class="toc-text">模板方法模式介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83"><span class="toc-number">1.2.7.</span> <span class="toc-text">核心</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E5%9B%9E%E8%B0%83-%E9%92%A9%E5%AD%90%E6%96%B9%E6%B3%95"><span class="toc-number">1.2.8.</span> <span class="toc-text">方法回调(钩子方法)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#when-use"><span class="toc-number">1.2.9.</span> <span class="toc-text">when use</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%80%E5%8F%91%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84%E5%9C%BA%E6%99%AF"><span class="toc-number">1.2.10.</span> <span class="toc-text">开发中常见的场景</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F-Observer"><span class="toc-number">1.3.</span> <span class="toc-text">观察者模式 Observer</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%BA%E6%99%AF%EF%BC%9A"><span class="toc-number">1.3.1.</span> <span class="toc-text">场景：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83-1"><span class="toc-number">1.3.2.</span> <span class="toc-text">核心</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%80%E5%8F%91%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84%E5%9C%BA%E6%99%AF%EF%BC%9A"><span class="toc-number">1.3.3.</span> <span class="toc-text">开发中常见的场景：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F-memento"><span class="toc-number">1.4.</span> <span class="toc-text">备忘录模式 memento</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83-2"><span class="toc-number">1.4.1.</span> <span class="toc-text">核心</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%93%E6%9E%84"><span class="toc-number">1.4.2.</span> <span class="toc-text">结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%80%E5%8F%91%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">1.4.3.</span> <span class="toc-text">开发中常见的应用场景</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F-state"><span class="toc-number">1.5.</span> <span class="toc-text">状态模式 state</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%BA%E6%99%AF"><span class="toc-number">1.5.1.</span> <span class="toc-text">场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%EF%BC%9A"><span class="toc-number">1.5.2.</span> <span class="toc-text">核心：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%EF%BC%9A"><span class="toc-number">1.5.3.</span> <span class="toc-text">结构：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%80%E5%8F%91%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84%E5%9C%BA%E6%99%AF%EF%BC%9A-1"><span class="toc-number">1.5.4.</span> <span class="toc-text">开发中常见的场景：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F-strategy"><span class="toc-number">1.6.</span> <span class="toc-text">策略模式 strategy</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%BA%E6%99%AF-1"><span class="toc-number">1.6.1.</span> <span class="toc-text">场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%AC%E8%B4%A8"><span class="toc-number">1.6.2.</span> <span class="toc-text">本质</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%80%E5%8F%91%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84%E5%9C%BA%E6%99%AF%EF%BC%9A-2"><span class="toc-number">1.6.3.</span> <span class="toc-text">开发中常见的场景：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F-Visitor"><span class="toc-number">1.7.</span> <span class="toc-text">访问者模式  Visitor</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E5%8A%A8%E6%9C%BA"><span class="toc-number">1.7.1.</span> <span class="toc-text">模式动机</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89"><span class="toc-number">1.7.2.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E5%9C%BA%E6%99%AF-%E5%BA%94%E7%94%A8%E8%8C%83%E5%9B%B4%E9%9D%9E%E5%B8%B8%E7%AA%84%EF%BC%8C%E4%BA%86%E8%A7%A3%E5%8D%B3%E5%8F%AF-%EF%BC%9A"><span class="toc-number">1.7.3.</span> <span class="toc-text">开发中的场景(应用范围非常窄，了解即可)：</span></a></li></ol></li></ol></li></ol></div></div></div></aside><main class="sidebar-translate" id="content"><div id="post"><article class="post-block" itemscope itemtype="https://schema.org/Article"><link itemprop="mainEntityOfPage" href="https://bingbuliang.github.io/2021/04/02/java-designer-mode-2/"><span hidden itemprop="author" itemscope itemtype="https://schema.org/Person"><meta itemprop="name" content="冰不良"><meta itemprop="description" content="设计者模式——2 结构型模式概述篇"></span><span hidden itemprop="publisher" itemscope itemtype="https://schema.org/Organization"><meta itemprop="name" content="冰不良のblog"></span><header class="post-header"><h1 class="post-title" itemprop="name headline" style="color: undefined">设计者模式——2 结构型模式概述篇</h1><div class="post-meta"><div class="post-time" style="display:inline-block"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-calendar-line"></use></svg></span> <time title="创建时间：2021-04-02 16:45:08" itemprop="dateCreated datePublished" datetime="2021-04-02T16:45:08+08:00">2021-04-02</time></div><div class="post-classify"><span class="post-tag"><a class="tag" href="/tags/java/" style="--text-color:#d04d2d"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-price-tag-3-line"></use></svg></span><span class="tag-name">java</span></a><a class="tag" href="/tags/%E8%AE%BE%E8%AE%A1%E8%80%85%E6%A8%A1%E5%BC%8F/"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-price-tag-3-line"></use></svg></span><span class="tag-name">设计者模式</span></a></span></div></div></header><section class="post-body" itemprop="articleBody"><div class="post-content post-markdown"><p><code>内容为自己学习账号听课的时候随堂笔记</code></p>
<h2 id="结构型模式-7"><a href="#结构型模式-7" class="headerlink" title="结构型模式  7"></a>结构型模式  7</h2><h4 id="核心作用"><a href="#核心作用" class="headerlink" title="核心作用"></a>核心作用</h4><p>是从程序的结构上实现松耦合，从而可以扩大整体的类结构，用来解决更大的问题。</p>
<h4 id="汇总"><a href="#汇总" class="headerlink" title="汇总"></a>汇总</h4><ul>
<li><p>代理模式 </p>
<p>为真实对象提供一个代理，从而控制对真实对象的访问</p>
</li>
<li><p>适配模式 </p>
<p>使原本由于接口不兼容不能一起工作的类可以一起工作</p>
</li>
<li><p>桥接模式 </p>
<p>处理多层继承结构，处理多维度变化的场景，将各个维度设计成独立的继承结构，使各个维度可以独立的扩展在抽象层建立关联。</p>
</li>
<li><p>组合模式 </p>
<p>将对象组合成树状结构以表示”部分和整体”层次结构，使得客户可以统一的调用叶子对象和容器对象</p>
</li>
<li><p>装饰模式 </p>
<p>动态地给一个对象添加额外的功能，比继承灵活</p>
</li>
<li><p>外观模式 </p>
<p>为子系统提供统一的调用接口，使得子系统更加容易使用</p>
</li>
<li><p>享元模式 </p>
<p>运用共享技术有效的实现管理大量细粒度对象，节省内存，提高效率</p>
</li>
</ul>
<h3 id="适配器模式-adapter"><a href="#适配器模式-adapter" class="headerlink" title="适配器模式 adapter"></a>适配器模式 adapter</h3><pre class="language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;类适配器
class Adapter extends Adaptee implements Target&#123;
    public void request() &#123;
    	super.specificRequest();
    &#125;
&#125;

&#x2F;&#x2F;对象适配器 
class Adapter implements Target&#123;
    private Adaptee adaptee;
    public Adapter (Adaptee adaptee) &#123;
    	this.adaptee &#x3D; adaptee;
    &#125;
    public void request() &#123;
    	this.adaptee.specificRequest();
    &#125;
&#125;</code></pre>



<h4 id="什么是适配器模式"><a href="#什么是适配器模式" class="headerlink" title="什么是适配器模式?"></a>什么是适配器模式?</h4><p>将一个类的接口转换成客户希望的另外一个接口。Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以在一起工作。</p>
<h4 id="模式中的角色"><a href="#模式中的角色" class="headerlink" title="模式中的角色"></a>模式中的角色</h4><ul>
<li>目标接口（Target）：客户所期待的接口。目标可以是具体的或抽象的类，也可以是接口。</li>
<li>需要适配的类（Adaptee）：需要适配的类或适配者类。</li>
<li>适配器（Adapter）：通过包装一个需要适配的对象，把原接口转换成目标接口</li>
</ul>
<h4 id="工作中的场景"><a href="#工作中的场景" class="headerlink" title="工作中的场景"></a>工作中的场景</h4><ul>
<li>经常用来做旧系统改造和升级</li>
<li>如果我们的系统开发之后再也不需要维护，那么很多模式都是没必要的，但是不幸的是，事实却是维护一个系统的代价往往是开发一个系统的数倍。</li>
</ul>
<h4 id="学习中见过的场景"><a href="#学习中见过的场景" class="headerlink" title="学习中见过的场景"></a>学习中见过的场景</h4><ul>
<li>java.io.InputStreamReader(InputStream)</li>
<li>java.io.OutputStreamWriter(OutputStream</li>
</ul>
<h3 id="代理模式-Proxy-pattern"><a href="#代理模式-Proxy-pattern" class="headerlink" title="代理模式  Proxy pattern"></a>代理模式  Proxy pattern</h3><h4 id="核心作用-1"><a href="#核心作用-1" class="headerlink" title="核心作用"></a>核心作用</h4><p>通过代理，控制对对象的访问！ 从而实现将统一流程代码放到代理类中处理</p>
<p>可以详细控制访问某个（某类）对象的方法，在调用这个方法前做前置处理，调用这个方法后做后置处理。（即：AOP的微观实现！）</p>
<p>AOP(Aspect Oriented Programming面向切面编程)的核心实现机制！</p>
<h4 id="核心角色"><a href="#核心角色" class="headerlink" title="核心角色"></a>核心角色</h4><ul>
<li>抽象角色<br>定义代理角色和真实角色的公共对外方法</li>
<li>真实角色<br>实现抽象角色，定义真实角色所要实现的业务逻辑，供代理角色调用。<br>关注真正的业务逻辑！</li>
<li>代理角色<br>实现抽象角色，是真实角色的代理，通过真实角色的业务逻辑方法来实现抽象方法，并可以附加自己的操作。<br>将统一的流程控制放到代理角色中处理！</li>
</ul>
<h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><ul>
<li><p>安全代理：屏蔽对真实角色的直接访问。</p>
</li>
<li><p>远程代理：通过代理类处理远程方法调用(RMI)</p>
</li>
<li><p>延迟加载：先加载轻量级的代理对象，真正需要再加载真实对象。</p>
<p>比如你要开发一个大文档查看软件，大文档中有大的图片，有可能一个图片有100MB，在打开文件时不可能将所有的图片都显示出来，这样就可以使用代理模式，当需要查看图片时，用proxy来进行大图片的打开。</p>
</li>
</ul>
<h4 id="开发框架中应用场景："><a href="#开发框架中应用场景：" class="headerlink" title="开发框架中应用场景："></a>开发框架中应用场景：</h4><ul>
<li>Struts2中拦截器的实现</li>
<li>数据库连接池关闭处理</li>
<li>Hibernate中延时加载的实现</li>
<li>mybatis中实现拦截器插件</li>
<li>AspectJ的实现</li>
<li>spring中AOP的实现<ul>
<li>日志拦截</li>
<li>声明式事务处理</li>
</ul>
</li>
<li>web service</li>
<li>RMI远程方法调用</li>
</ul>
<h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><ul>
<li>静态代理(静态定义代理类) (static proxy)</li>
<li>动态代理(动态生成代理类) (dynamic proxy)<ul>
<li>JDK自带的动态代理</li>
<li>javaassist字节码操作库实现</li>
<li>CGLIB</li>
<li>ASM(底层使用指令，可维护性较差)</li>
</ul>
</li>
</ul>
<h5 id="动态代理相比于静态代理的优点"><a href="#动态代理相比于静态代理的优点" class="headerlink" title="动态代理相比于静态代理的优点"></a>动态代理相比于静态代理的优点</h5><p>抽象角色中(接口)声明的所以方法都被转移到调用处理器一个集中的方法中处理，这样，我们可以更加灵活和统一的处理众多的方法。</p>
<h5 id="JDK自带的动态代理"><a href="#JDK自带的动态代理" class="headerlink" title="JDK自带的动态代理"></a>JDK自带的动态代理</h5><ul>
<li><p>java.lang.reflect.Proxy</p>
<p>作用：动态生成代理类和对象</p>
</li>
<li><p>java.lang.reflect.InvocationHandler(处理器接口)</p>
<ul>
<li>可以通过invoke方法实现对真实角色的代理访问。</li>
<li>每次通过Proxy生成代理类对象对象时都要指定对应的处理器对象</li>
</ul>
</li>
<li><p>&#96;&#96;&#96;java<br>Star realStar &#x3D; new RealStar();<br>StarHandler handler &#x3D; new StarHandler(realStar);<br>Star proxy &#x3D; (Star) Proxy.newProxyInstance(ClassLoader.getSystemClassLoader(),new<br>Class[]{Star.class},handler);<br>proxy.sing()</p>
<pre class="language-none"><code class="language-none">
#### 面向切面编程介绍

+ AOP（Aspect-Oriented Programming，面向切面的编程），它是可以通过预编译方式和运行期动态代理实现在不修改源代码的情况下给程序动态统一添加功能的一种技术。它是一种新的方法论，它是对传统OOP编程的一种补充。
+ 常用术语：
  – 切面（Aspect）：其实就是共有功能的实现。
  – 通知（Advice）：是切面的具体实现。
  – 连接点（Joinpoint）：就是程序在运行过程中能够插入切面的地点。
  – 切入点（Pointcut）：用于定义通知应该切入到哪些连接点上。
  – 目标对象（Target）：就是那些即将切入切面的对象，也就是那些被通知的对象
  – 代理对象（Proxy）：将通知应用到目标对象之后被动态创建的对象。
  – 织入（Weaving）：将切面应用到目标对象从而创建一个新的代理对象的过程。
+ 开源的AOP框架： AspectJ

### 桥接模式 bridge

#### 场景分析

+ 商城系统中常见的商品分类，以电脑为类，如何良好的处理商品分类销售的问题?
+ 这个场景中有两个变化的维度：电脑类型、电脑品牌。

#### 核心要点

处理多层继承结构，处理多维度变化的场景，将各个维度设计成独立的继承结构，使各个维度可以独立的扩展在抽象层建立关联。

#### 总结

接模式极大的提高了系统可扩展性，在两个变化维度中任意扩展一个维度，都不需要修改原有的系统，符合开闭原则

就像一个桥，将两个变化维度连接起来。各个维度都可以独立的变化。故称之为：桥模式

#### 开发中应用场景

JDBC驱动程序

+ AWT中的Peer架构
+ 银行日志管理：
  + 格式分类：操作日志、交易日志、异常日志
  + 距离分类：本地记录日志、异地记录日志
+ 人力资源系统中的奖金计算模块：
  +  奖金分类：个人奖金、团体奖金、激励奖金。
  + 部门分类：人事部门、销售部门、研发部门。
+ OA系统中的消息处理：
  + 业务类型：普通消息、加急消息、特急消息
  + 发送消息方式：系统内消息、手机短信、邮件



### 组合模式 Composite

#### 场景

把部分和整体的关系用树形结构来表示，从而使客户端可以使用统一的方式处理部分对象和整体对象。

#### 核心

+ 抽象构件(Component)角色: 定义了叶子和容器构件的共同点
+  叶子(Leaf)构件角色：无子节点
+ 容器(Composite)构件角色： 有容器特征，可以包含子节点

#### 工作流程分析

+ 组合模式为处理树形结构提供了完美的解决方案，描述了如何将容器和叶子进行递归组合，使得用户在使用时可以一致性的对待容器和叶子。
+ 当容器对象的指定方法被调用时，将遍历整个树形结构，寻找也包含这个方法的成员，并调用执行。其中，使用了递归调用的机制对整个结构进行处理。

#### 开发中的应用场景

+ 操作系统的资源管理器

+ GUI中的容器层次图

+ XML文件解析

+ OA系统中，组织结构的处理

+ Junit单元测试框架

  底层设计就是典型的组合模式，TestCase(叶子)、TestUnite(容器)、Test接口(抽象)

### 装饰模式 decorator

#### 职责

+ 动态的为一个对象增加新的功能
+ 装饰模式是一种用于代替继承的技术，无须通过继承增加子类就能扩展对象的新功能。使用对象的关联关系代替继承关系，更加灵活，同时避免类型体系的快速膨胀

#### 核心

+ Component抽象构件角色：
  真实对象和装饰对象有相同的接口。这样，客户端对象就能够以与真实对象相同的方式同装饰对象交互。
+ ConcreteComponent 具体构件角色(真实对象)：
  io流中的FileInputStream、FileOutputStream
+ Decorator装饰角色：
  持有一个抽象构件的引用。装饰对象接受所有客户端的请求，并把这些请求转发给真实的对象。这样，就能在真实对象调用前后增加新的功能。
+ ConcreteDecorator具体装饰角色：
  负责给构件对象增加新的责任。

#### 开发中使用的场景

+ IO中输入流和输出流的设计
+ Swing包中图形界面构件功能
+ Servlet API 中提供了一个request对象的Decorator设计模式的默认实现类HttpServletRequestWrapper，HttpServletRequestWrapper类，增强了request对象的功能。
+ Struts2中，request，response,session对象的处理

#### IO流实现细节

+ Component抽象构件角色：
  io流中的InputStream、OutputStream、Reader、Writer
+ ConcreteComponent 具体构件角色：
  io流中的FileInputStream、FileOutputStream
+ Decorator装饰角色：
  持有一个抽象构件的引用：io流中的FilterInputStream、FilterOutputStream
+ ConcreteDecorator具体装饰角色：
  负责给构件对象增加新的责任。Io流中的BufferedOutputStream、BufferedInputStream等。

#### 总结

+ 装饰模式（Decorator）也叫包装器模式（Wrapper）
+ 装饰模式降低系统的耦合度，可以动态的增加或删除对象的职责，并使得需要装饰的具体构建类和具体装饰类可以独立变化，以便增加新的具体构建类和具体装饰类
+ 优点
  + 扩展对象功能，比继承灵活，不会导致类个数急剧增加
  + 可以对一个对象进行多次装饰，创造出不同行为的组合，得到功能更加强大的对象
  + 具体构建类和具体装饰类可以独立变化，用户可以根据需要自己增加新的具体构件子类和具体装饰子类。
+ 缺点
  + 产生很多小对象。大量小对象占据内存，一定程度上影响性能
  + 装饰模式易于出错，调试排查比较麻烦

#### 和桥接模式的区别

两个模式都是为了解决过多子类对象问题。但他们の诱因不一样。桥模式是对象自身现有机制沿着多个维度变化，是既有部分不稳定。装饰模式是为了增加新的功能。

### 外观模式 facade

#### 核心

为子系统提供统一的入口。封装子系统的复杂性，便于客户端调用。

#### 开发中常见的场景

频率很高。哪里都会遇到。各种技术和框架中，都有外观模式的使用。如：
	JDBC封装后的，commons提供的DBUtils类，Hibernate提供的工具类、Spring JDBC工具类等

### 享元模式

#### 场景

内存属于稀缺资源，不要随便浪费。如果有很多个完全相同或相似的对象，我们可以通过享元模式，节省内存。

#### 核心

+ 享元模式以共享的方式高效地支持大量细粒度对象的重用。
+ 享元对象能做到共享的关键是区分了内部状态和外部状态。
  + 内部状态：可以共享，不会随环境变化而改变
  + 外部状态：不可以共享，会随环境变化而改变

#### 实现

+ FlyweightFactory享元工厂类
  创建并管理享元对象，享元池一般设计成键值对
+ FlyWeight抽象享元类
  通常是一个接口或抽象类，声明公共方法，这些方法可以向外界提供对象的内部状态，设置外部状态。
+ ConcreteFlyWeight具体享元类
  为内部状态提供成员变量进行存储
+ UnsharedConcreteFlyWeight非共享享元类
  不能被共享的子类可以设计为非共享享元类

#### 开发中应用的场景

+ 享元模式由于其共享的特性，可以在任何“池”中操作，比如：线程池、数据库连接池。

+ String类的设计也是享元模式

#### 总结

+ 优点
  + 极大减少内存中对象的数量
  + 相同或相似对象内存中只存一份，极大的节约资源，提高系统性能
  + 外部状态相对独立，不影响内部状态
+ 缺点
  + 模式较复杂，使程序逻辑复杂化
  + 为了节省内存，共享了内部状态，分离出外部状态，而读取外部状态使运行时间变长。用时间换取了空间。

### 结构型模式汇总

1. 代理模式 

   为真实对象提供一个代理，从而控制对真实对象的访问

2. 适配模式 

   使原本由于接口不兼容不能一起工作的类可以一起工作

3. 桥接模式

   处理多层继承结构，处理多维度变化的场景，将各个维度设计成独立的继承结构，使各个维度可以独立的扩展在抽象层建立关联。

4. 组合模式 

   将对象组合成树状结构以表示”部分和整体”层次结构，使得客户可以统一
   的调用叶子对象和容器对象

5. 装饰模式 

   动态地给一个对象添加额外的功能，比继承灵活

6. 外观模式 

   为子系统提供统一的调用接口，使得子系统更加容易使用

7. 享元模式 

   运用共享技术有效的实现管理大量细粒度对象，节省内存，提高效率



## 行为型模式： 11

#### 对比

+ 行为型模式

  ​		关注系统中对象之间的相互交互研究系统在运行时对象之间的相互通信和协作进一步明确对象的职责，共有11种模式。

+ 创建型模式        

  ​		关注对象的创建过程

+ 结构型模式   

  ​		关注对象和类的组织

#### 汇总

| 责任链模式   | chain of responsibility |
| ------------ | ----------------------- |
| 命令模式     | command                 |
| 解释器模式   | interpreter             |
| 迭代器模式   | iterator                |
| 中介者模式   | mediator                |
| 备忘录模式   | memento                 |
| 观察者模式   | observer                |
| 状态模式     | state                   |
| 策略模式     | strategy                |
| 模板方法模式 | template method         |
| 访问者模式   | visitor                 |

### 责任链模式 chain of responsibility 

#### 定义

将能够处理同一类请求的对象连成一条链，所提交的请求沿着链传递，链上的对象逐个判断是否有能力处理该请求，如果能则处理，如果不能则传递给链上的下一个对象。

#### 场景:

- 打牌时，轮流出牌
- 接力赛跑
- 大学中，奖学金审批
- 公司中，公文审批
- 公司里面，报销个单据需要经过流程：
  • 申请人填单申请，申请给经理
  • 小于1000，经理审查。
  • 超过1000，交给总经理审批。
  • 总经理审批通过
- 公司里面，请假条的审批过程：
  • 如果请假天数小于3天，主任审批
  • 如果请假天数大于等于3天，小于10天，经理审批
  • 如果大于等于10天，小于30天，总经理审批
  • 如果大于等于30天，提示拒绝
- 公司里面，SCM(Supply Chain Management供应链管理)系统中，采购审批子系统的设计：
  • 采购金额小于5万，主任审批
  • 采购金额大于等于5万，小于10万，经理审批
  • 采购金额大于等于10万，小于20万，副总经理审批
  • 采购金额大于等于20万，总经理审批

#### 设计

由于责任链的创建完全在客户端，因此新增新的具体处理者对原有类库没有任何影响，只需添加新的类，然后在客户端调用时添加即可。符合开闭原则。

1. 链表方式

2. 非链表方式

   通过集合、数组生成职责链更加实用！实际上，很多项目中，每个具体的Handler并不是由开发团队定义的，而是项目上线后由外部单位追加的，所以使用链表方式定义COR链就很困难。

#### 开发中应用的场景

- Java中，异常机制就是一种责任链模式。一个try可以对应多个catch当第一个catch不匹配类型，则自动跳到第二个catch.
- Javascript语言中，事件的冒泡和捕获机制。Java语言中，事件的处理采用观察者模式。
- Servlet开发中，过滤器的链式处理
- Struts2中，拦截器的调用也是典型的责任链模式

### 迭代器模式 iterator

#### 场景

+ 提供一种可以遍历聚合对象的方式。又称为：游标cursor模式
+ 聚合对象：存储数据
+ 迭代器：遍历数据

#### 结构

+ 聚合对象：存储数据
+ 迭代器：遍历数据

#### 开发中常见的场景

JDK内置的迭代器(List&#x2F;Set）

### 中介者模式 Mediator

#### 核心

- 如果一个系统中对象之间的联系呈现为网状结构，对象之间存在大量多对多关系，将导致关系及其复杂，这些对象称为“&#x3D;&#x3D;同事对象&#x3D;&#x3D;”
- 我们可以引入一个&#x3D;&#x3D;中介者对象&#x3D;&#x3D;，使各个同事对象只跟中介者对象打交道，将复杂的网络结构化解为如下的星形结构。
- 解耦多个同事对象之间的交互关系。每个对象都持有中介者对象的引用，只跟中介者对象打交道。我们通过中介者对象统一管理这些交互关系

#### 开发中常见的场景

+ MVC模式(其中的C，控制器就是一个中介者对象。M和V都和他打交道)
+ 窗口游戏程序，窗口软件开发中窗口对象也是一个中介者对象
+ 图形界面开发GUI中，多个组件之间的交互，可以通过引入一个中介者对象来解决，可以是整体的窗口对象或者DOM对象
+ Java.lang.reflect.Method#invoke()

### 命令模式 command

#### 介绍

命令模式:将一个请求封装为一个对象，从而使我们可用不同的请求对客户进行参数化;对请求排队或者记录请求志，以及支持可撤销的操作。也称之为:动作Action模式、事务transaction模式

#### 结构

+ Command抽象命令类
+ ConcreteCommand具体命令类

- Invoker周用者&#x2F;请求者

  请求的发送者，它通过命令对象来执行请求。一个调用者并不需要在设计时确定其接收者，因此它只与抽象命令类之间存在关联。在程序运行时，将调用命令对象的execute()，间接调用接收者的相关操作。

- Receiver接收者

  - 接收者执行与请求相关的操作，具体实现对请求的业务处理。
  - 未抽象前，实际执行操作内容的对象

- Client客户类
  在客户类中需要创建调用者对象、具体命令类对象，在创建具体命令对象时指定对应的接收者。发送者和接收者之间没有直接关系，都通过命令对象间接调用。

#### 开发中常见的场景：

+ Struts2中，action的整个调用过程中就有命令模式。
+ 数据库事务机制的底层实现
+ 命令的撤销和恢复

### 解释器模式 Interpreter

#### 介绍

+ 是一种不常用的设计模式
+ 用于描述如何构成一个简单的语言解释器，主要用于使用面向对象语言开发的
  编译器和解释器设计。
+ 当我们需要开发一种新的语言时，可以考虑使用解释器模式。
+ 尽量不要使用解释器模式，后期维护会有很大麻烦。在项目中，可以使用Jruby，Groovy、java的js引擎来替代解释器的作用，弥补java语言的不足。

#### 开发中常见的场景

+ EL表达式式的处理
+ 正则表达式解释器
+ SQL语法的解释器
+ 数学表达式解析器
  如现成的工具包:Math Expression String Parser、Expression4J等。
  + MESP的网址： http:&#x2F;&#x2F;sourceforge.net&#x2F;projects&#x2F;expression-tree&#x2F;
  + Expression4J的网址： http:&#x2F;&#x2F;sourceforge.net&#x2F;projects&#x2F;expression4j&#x2F;

### 模版方法模式 template method

#### 场景

- 客户到银行办理业务

  1. 取号排队
  2. 办理具体现金&#x2F;转账&#x2F;企业&#x2F;个人&#x2F;理财业务
  3. 给银行工作人员评分

  &#96;&#96;&#96;java
  public abstract class BankTemplateMethod &#123;
      &#x2F;&#x2F;具体方法
      public void takeNumber()&#123;
      	System.out.println(&quot;取号排队&quot;);
      &#125;
      public abstract void transact(); &#x2F;&#x2F;办理具体的业务 &#x2F;&#x2F;钩子方法
      public void evaluate()&#123;
      	System.out.println(&quot;反馈评分&quot;);
      &#125;
      
      &#x2F;&#x2F; 模板方法, 把基本操作组合到一起，子类一般不能重写
      public final void process()&#123;
          this.takeNumber();
          &#x2F;&#x2F; 像个钩子。执行时，挂哪个子类的方法就调用哪个
          this.transact();
          this.evaluate();
      &#125;
  &#125;</code></pre></li>
</ul>
<h4 id="模板方法模式介绍"><a href="#模板方法模式介绍" class="headerlink" title="模板方法模式介绍"></a>模板方法模式介绍</h4><p>模板方法模式是编程中经常用得到模式。它定义了一个操作中的算法骨架，将某些步骤延迟到子类中实现。这样，新的子类可以在不改变一个算法结构的前提下重新定义该算法的某些特定步骤。</p>
<h4 id="核心"><a href="#核心" class="headerlink" title="核心"></a>核心</h4><p>处理某个流程的代码已经都具备，但是其中某个节点的代码暂时不能确定。因此，我们采用工厂方法模式，将这个节点的代码实现转移给子类完成。即 : &#x3D;&#x3D;处理步骤父类中定义好，具体实现延迟到子类中定义&#x3D;&#x3D;</p>
<h4 id="方法回调-钩子方法"><a href="#方法回调-钩子方法" class="headerlink" title="方法回调(钩子方法)"></a>方法回调(钩子方法)</h4><ul>
<li>好莱坞原则”Don’t call me，we’ ll call you back<br>在好莱坞，当艺人把简历递交给好莱坞的娱乐公司时，所能做的就是等待，整个过程由娱乐公可控制，演员只能被动地服冬安排，在需要的时候再由公司安排具体环节的演出。</li>
<li>在软件开发中，我们可以将call翻译为调用。子类不能调用父类，而通过父类调用子类。这些调用步骤已经在父类中写好了，完全由父类控制整个过程</li>
</ul>
<h4 id="when-use"><a href="#when-use" class="headerlink" title="when use"></a>when use</h4><p>实现一个算法时，整体步骤很固定。但是，某些部分易变。易变部分可以抽象成出来，供子类实现。</p>
<h4 id="开发中常见的场景"><a href="#开发中常见的场景" class="headerlink" title="开发中常见的场景"></a>开发中常见的场景</h4><p>非常频繁。各个框架类库中都有他的影子。比如常见的有:</p>
<ul>
<li>数据库访问的封装</li>
<li>Junit单元测试</li>
<li>servlet中关于doGet&#x2F;doPost方法调用</li>
<li>Hibernate中模板程序</li>
<li>spring中JDBCTemplate、HibernateTemplate等.</li>
</ul>
<h3 id="观察者模式-Observer"><a href="#观察者模式-Observer" class="headerlink" title="观察者模式 Observer"></a>观察者模式 Observer</h3><h4 id="场景："><a href="#场景：" class="headerlink" title="场景："></a>场景：</h4><ul>
<li><p>聊天室程序的创建。服务器创建好后，A,B,C三个客户端连上来公开聊天。A向服务器发送数据，服务器端聊天数据改变。我们希望将这些聊天数据分别发给其他在线的客户。也就是说，每个客户端需要更新服务器端得数据。</p>
</li>
<li><p>网站上，很多人订阅了”java主题”的新闻。当有这个主题新闻时，就会将这些新闻发给所有订阅的人。</p>
</li>
<li><p>大家一起玩CS游戏时，服务器需要将每个人的方位变化发给所有的客户</p>
<p>上面这些场景，我们都可以使用观察者模式来处理。我们可以把多个订阅者、客户称之为观察者； 需要同步给多个订阅者的数据封装到对象中，称之为目标。</p>
</li>
</ul>
<h4 id="核心-1"><a href="#核心-1" class="headerlink" title="核心"></a>核心</h4><ul>
<li>观察者模式主要用于1:N的通知。当一个对象(目标对象Subject或Obiservable)的状态变化时，&#x3D;&#x3D;消息订阅&#x3D;&#x3D;他需要及时告知一系列对象(观察者对象,Observer)，&#x3D;&#x3D;消息订阅&#x3D;&#x3D;令他们做出响应</li>
<li>通知观察者的方式: <ul>
<li>推<br>每次都会把通知以广播方式发送给所有观察者，所有观察者只能被动接收。</li>
<li>拉<br>观察者只要直到有情况即可。至于什么时候获取内容，获取什么内容都可以自主决定</li>
</ul>
</li>
<li>JAVASE提供了java.util.Observable和java.util.Observer来实现观察者模式</li>
</ul>
<h4 id="开发中常见的场景："><a href="#开发中常见的场景：" class="headerlink" title="开发中常见的场景："></a>开发中常见的场景：</h4><ul>
<li>聊天室程序的，服务器转发给所有客户端</li>
<li>网络游戏(多人联机对战)场景中，服务器将客户端的状态进行分发<br>– 邮件订阅<br>– Servlet中，监听器的实现<br>– Android中，广播机制<br>– JDK的AWT中事件处理模型,基于观察者模式的委派事件模型(Delegation Event<br>Model)<br>• 事件源—————-目标对象<br>• 事件监听器————观察者<br>– 京东商城中，群发某商品打折信息</li>
</ul>
<h3 id="备忘录模式-memento"><a href="#备忘录模式-memento" class="headerlink" title="备忘录模式 memento"></a>备忘录模式 memento</h3><ul>
<li>录入大批人员资料。正在录入当前人资料时，发现上一个人录错了，此时需要恢复上一个人的资料，再进行修改。</li>
<li>Word文档编辑时，忽然电脑死机或断电，再打开时，可以看到word<br>提示你恢复到以前的文档</li>
<li>管理系统中，公文撤回功能。公文发送出去后，想撤回来。</li>
</ul>
<h4 id="核心-2"><a href="#核心-2" class="headerlink" title="核心"></a>核心</h4><p>就是保存某个对象内部状态的拷贝，这样以后就可以将该对象恢复到原先的状态。</p>
<h4 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h4><ul>
<li>源发器类Originator</li>
<li>备忘录类Memento</li>
<li>负责人类CareTaker</li>
</ul>
<h4 id="开发中常见的应用场景"><a href="#开发中常见的应用场景" class="headerlink" title="开发中常见的应用场景"></a>开发中常见的应用场景</h4><ul>
<li>棋类游戏中的，悔棋</li>
<li>普通软件中的，撤销操作</li>
<li>数据库软件中的，事务管理中的，回滚操作</li>
<li>Photoshop软件中的，历史记录</li>
</ul>
<h3 id="状态模式-state"><a href="#状态模式-state" class="headerlink" title="状态模式 state"></a>状态模式 state</h3><h4 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h4><ul>
<li>电梯的运行<br>• 维修、正常、自动关门、自动开门、向上运行、向下运行、消防状态</li>
<li>红绿灯<br>• 红灯、黄灯、绿灯</li>
<li>企业或政府系统<br>• 公文的审批状态</li>
<li>报销单据审批状态</li>
<li>假条审批</li>
<li>网上购物时，订单的状态<br>• 下单<br>• 已付款<br>• 已发货<br>• 送货中<br>• 已收货</li>
<li>酒店系统中，房间的状态变化：<br>• 已预订<br>• 已入住<br>• 空闲</li>
</ul>
<h4 id="核心："><a href="#核心：" class="headerlink" title="核心："></a>核心：</h4><p>​		用于解决系统中复杂对象的状态转换以及不同状态下行为的封装问题</p>
<h4 id="结构："><a href="#结构：" class="headerlink" title="结构："></a>结构：</h4><ul>
<li>Context环境类<br>环境类中维护一个State对象，他是定义了当前的状态。</li>
<li>State抽象状态类</li>
<li>ConcreteState具体状态类<br>每一个类封装了一个状态对应的行为</li>
</ul>
<h4 id="开发中常见的场景：-1"><a href="#开发中常见的场景：-1" class="headerlink" title="开发中常见的场景："></a>开发中常见的场景：</h4><ul>
<li>银行系统中账号状态的管理</li>
<li>OA系统中公文状态的管理</li>
<li>酒店系统中，房间状态的管理</li>
<li>线程对象各状态之间的切换</li>
</ul>
<h3 id="策略模式-strategy"><a href="#策略模式-strategy" class="headerlink" title="策略模式 strategy"></a>策略模式 strategy</h3><h4 id="场景-1"><a href="#场景-1" class="headerlink" title="场景"></a>场景</h4><ul>
<li>某个市场人员接到单后的报价策略(CRM系统中常见问题)。报价策略很复杂，可以简单作如下分类：<br>• 普通客户小批量报价<br>• 普通客户大批量报价<br>• 老客户小批量报价<br>• 老客户大批量报价</li>
<li>具体选用哪个报价策略，这需要根据实际情况来确定。这时候，我们采用策略模式即可。</li>
<li>假如，类型特别多，算法比较复杂时，整个条件控制代码会变得很长，难于维护。</li>
<li>策略模式对应于解决某一个问题的一个算法族，允许用户从该算法族中任选一个算法解决某一问题，同时可以方便的更换算法或者增加新的算法。并且由客户端决定调用哪个算法。</li>
</ul>
<h4 id="本质"><a href="#本质" class="headerlink" title="本质"></a>本质</h4><p>分离算法，选择实现。</p>
<h4 id="开发中常见的场景：-2"><a href="#开发中常见的场景：-2" class="headerlink" title="开发中常见的场景："></a>开发中常见的场景：</h4><ul>
<li>JAVASE中GUI编程中，布局管理</li>
<li>Spring框架中，Resource接口，资源访问策略</li>
<li>javax.servlet.http.HttpServlet#service()</li>
</ul>
<h3 id="访问者模式-Visitor"><a href="#访问者模式-Visitor" class="headerlink" title="访问者模式  Visitor"></a>访问者模式  Visitor</h3><h4 id="模式动机"><a href="#模式动机" class="headerlink" title="模式动机"></a>模式动机</h4><p>对于存储在一个集合中的对象，他们可能具有不同的类型(即使有一个公共的接口)，对于该集合中的对象，可以接受一类称为访问者的对象来访问，不同的访问者其访问方式也有所不同。</p>
<h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>表示一个作用于某对象结构中的各元素的操作，它使我们可以在不改变个元素的类的前提下定义作用于这些元素的新操作。</p>
<h4 id="开发中的场景-应用范围非常窄，了解即可-："><a href="#开发中的场景-应用范围非常窄，了解即可-：" class="headerlink" title="开发中的场景(应用范围非常窄，了解即可)："></a>开发中的场景(应用范围非常窄，了解即可)：</h4><ul>
<li>XML文档解析器设计</li>
<li>编译器的设计</li>
<li>复杂集合对象的处理</li>
</ul>
</div><div id="reward-container"><span class="hty-icon-button button-glow" id="reward-button" title="打赏" onclick="var qr = document.getElementById(&quot;qr&quot;); qr.style.display = (qr.style.display === &quot;none&quot;) ? &quot;block&quot; : &quot;none&quot;;"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-hand-coin-line"></use></svg></span><div id="reward-comment">I'm so cute. Please give me money.</div><div id="qr" style="display:none;"><div style="display:inline-block"></div><div style="display:inline-block"></div><div style="display:inline-block"></div></div></div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者：</strong>冰不良</li><li class="post-copyright-link"><strong>本文链接：</strong><a href="https://bingbuliang.github.io/2021/04/02/java-designer-mode-2/" title="设计者模式——2 结构型模式概述篇">https://bingbuliang.github.io/2021/04/02/java-designer-mode-2/</a></li><li class="post-copyright-license"><strong>版权声明：</strong>本博客所有文章除特别声明外，均默认采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="noopener" title="CC BY-NC-SA 4.0 "><svg class="icon"><use xlink:href="#icon-creative-commons-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-by-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-nc-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-sa-line"></use></svg></a> 许可协议。</li></ul></section></article><div class="post-nav"><div class="post-nav-item"><a class="post-nav-prev" href="/2021/04/03/java-designer-mode-3/" rel="prev" title="设计者模式——3 行为型模式概述篇"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-left-s-line"></use></svg><span class="post-nav-text">设计者模式——3 行为型模式概述篇</span></a></div><div class="post-nav-item"><a class="post-nav-next" href="/2021/04/01/java-designer-mode-1/" rel="next" title="设计者模式——1 创建模型概述篇"><span class="post-nav-text">设计者模式——1 创建模型概述篇</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-right-s-line"></use></svg></a></div></div></div><div id="comment"><div class="comment-tooltip text-center"><span>若您无 GitHub 账号，可直接在下方匿名评论。</span><br><span>若您想及时得到回复提醒，建议跳转 GitHub Issues 评论。</span><br><span>若没有本文 Issue，您可以使用 Comment 模版新建。</span><br><a class="hty-button hty-button--raised" id="github-issues" target="_blank" rel="noopener" href="https://github.com/BingBuLiang/BingBuLiang.github.io/issues?q=is:issue+设计者模式——2 结构型模式概述篇">GitHub Issues</a></div></div></main><footer class="sidebar-translate" id="footer"><div class="beian"><a rel="noopener" href="https://www.beian.miit.gov.cn" target="_blank"></a></div><div class="copyright"><span>&copy; Sun Feb 02 2020 08:00:00 GMT+0800 (中国标准时间) – 2023 </span><span class="with-love" id="animate"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-cloud-line"></use></svg></span><span class="author"> 冰不良</span></div><div class="powered"><span>由 <a href="https://hexo.io" target="_blank" rel="noopener">Hexo</a> 驱动 v6.3.0</span><span class="footer-separator">|</span><span>主题 - <a rel="noopener" href="https://github.com/YunYouJun/hexo-theme-yun" target="_blank"><span>Yun</span></a> v0.7.1</span></div><div class="live_time"><span>本博客已萌萌哒地运行</span><span id="display_live_time"></span><span class="moe-text">(●'◡'●)</span><script>function blog_live_time() {
  window.setTimeout(blog_live_time, 1000);
  const start = new Date('2020-02-02T00:00:00');
  const now = new Date();
  const timeDiff = (now.getTime() - start.getTime());
  const msPerMinute = 60 * 1000;
  const msPerHour = 60 * msPerMinute;
  const msPerDay = 24 * msPerHour;
  const passDay = Math.floor(timeDiff / msPerDay);
  const passHour = Math.floor((timeDiff % msPerDay) / 60 / 60 / 1000);
  const passMinute = Math.floor((timeDiff % msPerHour) / 60 / 1000);
  const passSecond = Math.floor((timeDiff % msPerMinute) / 1000);
  display_live_time.innerHTML = " " + passDay + " 天 " + passHour + " 小时 " + passMinute + " 分 " + passSecond + " 秒";
}
blog_live_time();
</script></div></footer><a class="hty-icon-button" id="goUp" aria-label="back-to-top" href="#"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-up-s-line"></use></svg><svg class="progress-circle-container" viewBox="0 0 100 100"><circle class="progress-circle" id="progressCircle" cx="50" cy="50" r="48" fill="none" stroke="#6200ee" stroke-width="2" stroke-linecap="round"></circle></svg></a><a class="popup-trigger hty-icon-button icon-search" id="search" href="javascript:;" title="搜索"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-search-line"></use></svg></span></a><script defer src="/js/search/index.js"></script><script defer src="https://cdn.jsdelivr.net/npm/algoliasearch@4/dist/algoliasearch-lite.umd.js"></script><script defer src="https://cdn.jsdelivr.net/npm/instantsearch.js@4/dist/instantsearch.production.min.js"></script><script defer src="/js/search/algolia-search.js"></script><div class="popup search-popup"><div class="search-header"><span class="popup-btn-close close-icon hty-icon-button"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-close-line"></use></svg></span></div><div class="search-input-container"></div><div class="algolia-results"><div id="algolia-stats"></div><div id="algolia-hits"></div><div class="algolia-pagination" id="algolia-pagination"></div></div></div><script>let date = new Date();
let today = (date.getMonth() + 1) + "-" + date.getDate()
if ("4-4".indexOf(today) !== -1) {
  document.documentElement.style.filter = "grayscale(1)";
}</script></div><script defer src="/js/hexo-theme-yun.js"></script></body></html>