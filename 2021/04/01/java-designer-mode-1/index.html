<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="description" content="设计者模式——1 创建模型概述篇"><meta name="keywords" content="java,设计者模式"><meta name="author" content="冰不良"><meta name="copyright" content="冰不良"><meta name="theme-color" content="#6200ee"><title>设计者模式——1 创建模型概述篇 | 冰不良のblog</title><link rel="shortcut icon" href="/yun.svg"><link rel="mask-icon" href="/yun.svg" color="#6200ee"><link rel="preload" href="/css/hexo-theme-yun.css" as="style"><link rel="preload" href="/js/hexo-theme-yun.js" as="script"><link rel="prefetch" href="/js/sidebar.js" as="script"><link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin><link rel="stylesheet" href="/css/hexo-theme-yun.css"><script id="yun-config">
    window.CONFIG = {"root":"/","title":"冰不良の小站","version":"0.7.1","anonymous_image":"https://cdn.jsdelivr.net/gh/YunYouJun/cdn/img/avatar/none.jpg","say":{"api":"https://v1.hitokoto.cn","hitokoto":true},"algolia":{"appID":"5WNMZVZKKS","apiKey":"b66222e466f2046a9accd67fc9fcbe08","indexName":"hexo","hits":{"per_page":8},"labels":{"input_placeholder":"搜索文章","hits_empty":"找不到您查询的内容: ${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},"fireworks":{"colors":["102, 167, 221","62, 131, 225","33, 78, 194"]}};
  </script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" defer></script><script src="/js/load-aplayer.js" defer></script><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@900&amp;display=swap" media="none" onload="this.media='all'"><script src="//at.alicdn.com/t/font_1140697_rtqh36oinzl.js" async></script><link rel="preconnect" href="https://www.google-analytics.com" crossorigin><link rel="preconnect" href="https://stats.g.doubleclick.net" crossorigin><script async src="https://www.googletagmanager.com/gtag/js?id=UA-7FZJ6MEGB5-G"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-7FZJ6MEGB5-G');</script><script>(function(){
  var bp = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  if (curProtocol === 'https') {
    bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
  }
  else {
    bp.src = 'http://push.zhanzhang.baidu.com/push.js';
  }
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(bp, s);
})();</script><script src="https://cdn.jsdelivr.net/npm/pjax@latest/pjax.min.js" defer></script><script src="/js/pjax.js" defer></script><div class="js-Pjax"></div><meta name="generator" content="Hexo 6.3.0"><link rel="stylesheet" href="/css/prism.css" type="text/css"></head><body><script defer src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script defer src="/js/ui/fireworks.js"></script><canvas class="fireworks"></canvas><canvas id="trianglify"></canvas><script defer src="https://cdn.jsdelivr.net/npm/trianglify@latest/dist/trianglify.min.js"></script><script>document.addEventListener("DOMContentLoaded", () => {
  const pattern = Trianglify({
    width: 800,
    height: 600,
    cell_size: 75,
    palette: ["YlGnBu", "GnBu", "Purples", "Blues"],
  });
  document.body.appendChild(pattern.canvas(trianglify));
});</script><div class="container"><a class="sidebar-toggle sidebar-toggle-fixed hty-icon-button"><div class="hamburger hamburger--spin" type="button"><span class="hamburger-box"><span class="hamburger-inner"></span></span></div></a><aside class="sidebar"><script defer src="/js/sidebar.js"></script><ul class="sidebar-nav"><li class="sidebar-nav-item sidebar-nav-toc hty-icon-button sidebar-nav-active" data-target="post-toc-wrap" title="文章目录"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-list-ordered"></use></svg></li><li class="sidebar-nav-item sidebar-nav-overview hty-icon-button" data-target="site-overview-wrap" title="站点概览"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-passport-line"></use></svg></li></ul><div class="sidebar-panel" id="site-overview-wrap"><div class="site-info fix-top"><a class="site-author-avatar" href="/about" title="冰不良"><img width="96" loading="lazy" src="/images/%E5%A4%B4%E5%83%8F.jpg" alt="冰不良"></a><div class="site-author-name"><a href="/about/">冰不良</a></div><a class="site-name" href="/about/site.html">冰不良のblog</a><sub class="site-subtitle"></sub><div class="site-desciption">快来和我一起秃头吧！</div></div><nav class="site-state"><a class="site-state-item hty-icon-button icon-home" href="/" title="我的主页"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-home-4-line"></use></svg></span></a><div class="site-state-item site-state-posts"><a href="/archives" title="归档"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-archive-line"></use></svg></span><span class="site-state-item-count">19</span></a></div><div class="site-state-item site-state-tags"><a href="/tags" title="标签"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-price-tag-3-line"></use></svg></span><span class="site-state-item-count">16</span></a></div><a class="site-state-item hty-icon-button" href="/about/#comment" title="留言板"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-clipboard-line"></use></svg></span></a></nav><hr style="margin-bottom:0.5rem"><div class="links-of-author"><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://wpa.qq.com/msgrd?v=3&amp;uin=2330181012&amp;site=qq&amp;menu=yes" title="QQ" target="_blank" style="color:#12B7F5"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-qq-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://github.com/BingBuLiang" title="GitHub" target="_blank" style="color:#181717"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-github-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="mailto:bingbuliang996@163.com" title="E-Mail" target="_blank" style="color:#8E71C1"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-mail-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://weibo.com/u/5648709252" title="微博" target="_blank" style="color:#E6162D"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-weibo-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://music.163.com/" title="网易云音乐" target="_blank" style="color:#C10D0C"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-netease-cloud-music-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://www.zhihu.com/people/bing-bu-liang-xian-sen?utm_id=0" title="知乎" target="_blank" style="color:#0084FF"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-zhihu-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://space.bilibili.com/470508529" title="哔哩哔哩" target="_blank" style="color:#FF8EB3"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-bilibili-line"></use></svg></a></div><hr style="margin:0.5rem 1rem"><div class="links"><a class="links-item hty-icon-button" href="/links/" title="我的小伙伴们" style="color:dodgerblue"><i class="ri:genderless-line"></i></a></div></div><div class="sidebar-panel sidebar-panel-active" id="post-toc-wrap"><div class="post-toc"><div class="post-toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F-5"><span class="toc-number">1.</span> <span class="toc-text">创建型模式  5</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F-Singleton-Pattern"><span class="toc-number">1.1.</span> <span class="toc-text">单例模式 Singleton Pattern</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E4%BD%9C%E7%94%A8%EF%BC%9A"><span class="toc-number">1.1.1.</span> <span class="toc-text">核心作用：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9A"><span class="toc-number">1.1.2.</span> <span class="toc-text">常见应用场景：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%BC%98%E7%82%B9"><span class="toc-number">1.1.3.</span> <span class="toc-text">单例模式的优点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E4%BA%94%E7%A7%8D%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%EF%BC%9A"><span class="toc-number">1.1.4.</span> <span class="toc-text">常见的五种单例模式实现方式：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E9%80%89%E7%94%A8"><span class="toc-number">1.1.5.</span> <span class="toc-text">如何选用?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A5%BF%E6%B1%89%E5%BC%8F%E5%AE%9E%E7%8E%B0%EF%BC%88%E5%8D%95%E4%BE%8B%E5%AF%B9%E8%B1%A1%E7%AB%8B%E5%8D%B3%E5%8A%A0%E8%BD%BD%EF%BC%89"><span class="toc-number">1.1.6.</span> <span class="toc-text">饿汉式实现（单例对象立即加载）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%82%B9%E8%AF%84%EF%BC%9A"><span class="toc-number">1.1.6.1.</span> <span class="toc-text">点评：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%87%92%E6%B1%89%E5%BC%8F%E5%AE%9E%E7%8E%B0%EF%BC%88%E5%8D%95%E4%BE%8B%E5%AF%B9%E8%B1%A1%E5%BB%B6%E8%BF%9F%E5%8A%A0%E8%BD%BD%EF%BC%89"><span class="toc-number">1.1.7.</span> <span class="toc-text">懒汉式实现（单例对象延迟加载）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%82%B9%E8%AF%84"><span class="toc-number">1.1.7.1.</span> <span class="toc-text">点评</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8C%E9%87%8D%E6%A3%80%E6%B5%8B%E9%94%81%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.1.8.</span> <span class="toc-text">双重检测锁实现</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%82%B9%E8%AF%84-1"><span class="toc-number">1.1.8.1.</span> <span class="toc-text">点评</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F-%E4%B9%9F%E6%98%AF%E4%B8%80%E7%A7%8D%E6%87%92%E5%8A%A0%E8%BD%BD%E6%96%B9%E5%BC%8F%EF%BC%89"><span class="toc-number">1.1.9.</span> <span class="toc-text">静态内部类实现方式(也是一种懒加载方式）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%82%B9%E8%AF%84-2"><span class="toc-number">1.1.9.1.</span> <span class="toc-text">点评</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%82%B9%E8%AF%84-3"><span class="toc-number">1.1.9.2.</span> <span class="toc-text">点评</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E4%BA%94%E7%A7%8D%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E5%9C%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%9A%84%E6%95%88%E7%8E%87%E6%B5%8B%E8%AF%95"><span class="toc-number">1.1.10.</span> <span class="toc-text">常见的五种单例模式在多线程环境下的效率测试</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#CountDownLatch-%EF%BC%88%E5%90%8C%E6%AD%A5%E5%B7%A5%E5%85%B7%E7%B1%BB%EF%BC%89"><span class="toc-number">1.1.10.1.</span> <span class="toc-text">CountDownLatch （同步工具类）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F-%EF%BC%88%E5%8C%85%E6%8B%AC%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%EF%BC%89-Factory"><span class="toc-number">1.2.</span> <span class="toc-text">工厂模式 （包括抽象工厂） Factory</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8%EF%BC%9A"><span class="toc-number">1.2.1.</span> <span class="toc-text">作用：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E6%9C%AC%E8%B4%A8"><span class="toc-number">1.2.2.</span> <span class="toc-text">核心本质</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%A6%E7%BB%86%E5%88%86%E7%B1%BB%EF%BC%9A"><span class="toc-number">1.2.3.</span> <span class="toc-text">详细分类：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">1.2.4.</span> <span class="toc-text">应用场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E5%88%99%EF%BC%9A"><span class="toc-number">1.2.5.</span> <span class="toc-text">面向对象设计的基本原则：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8D%E4%BD%BF%E7%94%A8%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E7%9A%84%E6%83%85%E5%86%B5"><span class="toc-number">1.2.6.</span> <span class="toc-text">不使用简单工厂的情况</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.2.7.</span> <span class="toc-text">简单工厂模式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%82%B9%E8%AF%84-4"><span class="toc-number">1.2.7.1.</span> <span class="toc-text">点评</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.2.8.</span> <span class="toc-text">工厂方法模式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%82%B9%E8%AF%84-5"><span class="toc-number">1.2.8.1.</span> <span class="toc-text">点评</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8FPK"><span class="toc-number">1.2.9.</span> <span class="toc-text">简单工厂模式和工厂方法模式PK:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F-Abstract-Factory-Pattern"><span class="toc-number">1.2.10.</span> <span class="toc-text">抽象工厂模式 Abstract Factory Pattern</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%82%B9%E8%AF%84-6"><span class="toc-number">1.2.10.1.</span> <span class="toc-text">点评</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F-Builder-Pattern"><span class="toc-number">1.3.</span> <span class="toc-text">建造者模式 Builder Pattern</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E6%9C%AC%E8%B4%A8-1"><span class="toc-number">1.3.1.</span> <span class="toc-text">核心本质</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%BA%E6%99%AF"><span class="toc-number">1.3.2.</span> <span class="toc-text">场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-1"><span class="toc-number">1.3.3.</span> <span class="toc-text">应用场景</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F-prototype"><span class="toc-number">1.4.</span> <span class="toc-text">原型模式 prototype</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%BA%E6%99%AF%EF%BC%9A"><span class="toc-number">1.4.1.</span> <span class="toc-text">场景：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">1.4.2.</span> <span class="toc-text">开发中的应用场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%82%B9%E8%AF%84%EF%BC%9A-1"><span class="toc-number">1.4.3.</span> <span class="toc-text">点评：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F%E5%AE%9E%E7%8E%B0%EF%BC%9A"><span class="toc-number">1.4.4.</span> <span class="toc-text">原型模式实现：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%85%E5%85%8B%E9%9A%86%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">1.4.5.</span> <span class="toc-text">浅克隆存在的问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B7%B1%E5%85%8B%E9%9A%86%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.4.6.</span> <span class="toc-text">深克隆如何实现?</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%8A%80%E6%9C%AF%E5%AE%9E%E7%8E%B0%E6%B7%B1%E5%85%8B%E9%9A%86%EF%BC%81"><span class="toc-number">1.4.6.1.</span> <span class="toc-text">利用序列化和反序列化技术实现深克隆！</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93"><span class="toc-number">1.5.</span> <span class="toc-text">创建型模式总结</span></a></li></ol></li></ol></div></div></div></aside><main class="sidebar-translate" id="content"><div id="post"><article class="post-block" itemscope itemtype="https://schema.org/Article"><link itemprop="mainEntityOfPage" href="https://bingbuliang.github.io/2021/04/01/java-designer-mode-1/"><span hidden itemprop="author" itemscope itemtype="https://schema.org/Person"><meta itemprop="name" content="冰不良"><meta itemprop="description" content="设计者模式——1 创建模型概述篇"></span><span hidden itemprop="publisher" itemscope itemtype="https://schema.org/Organization"><meta itemprop="name" content="冰不良のblog"></span><header class="post-header"><h1 class="post-title" itemprop="name headline" style="color: undefined">设计者模式——1 创建模型概述篇</h1><div class="post-meta"><div class="post-time" style="display:inline-block"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-calendar-line"></use></svg></span> <time title="创建时间：2021-04-01 16:45:08" itemprop="dateCreated datePublished" datetime="2021-04-01T16:45:08+08:00">2021-04-01</time></div><div class="post-classify"><span class="post-tag"><a class="tag" href="/tags/java/" style="--text-color:#d04d2d"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-price-tag-3-line"></use></svg></span><span class="tag-name">java</span></a><a class="tag" href="/tags/%E8%AE%BE%E8%AE%A1%E8%80%85%E6%A8%A1%E5%BC%8F/"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-price-tag-3-line"></use></svg></span><span class="tag-name">设计者模式</span></a></span></div></div></header><section class="post-body" itemprop="articleBody"><div class="post-content post-markdown"><p><code>内容为自己学习账号听课的时候随堂笔记</code></p>
<h2 id="创建型模式-5"><a href="#创建型模式-5" class="headerlink" title="创建型模式  5"></a>创建型模式  5</h2><h3 id="单例模式-Singleton-Pattern"><a href="#单例模式-Singleton-Pattern" class="headerlink" title="单例模式 Singleton Pattern"></a>单例模式 Singleton Pattern</h3><h4 id="核心作用："><a href="#核心作用：" class="headerlink" title="核心作用："></a>核心作用：</h4><p>保证一个类只有一个实例，并且提供一个访问该实例的全局访问点</p>
<h4 id="常见应用场景："><a href="#常见应用场景：" class="headerlink" title="常见应用场景："></a>常见应用场景：</h4><ul>
<li>Windows的Task Manager（任务管理器）就是很典型的单例模式</li>
<li>windows的Recycle Bin（回收站）也是典型的单例应用。在整个系统运行过程中，回收站一直维护着仅有的一个实例。</li>
<li>项目中，读取配置文件的类，一般也只有一个对象。没有必要每次使用配置文件数据，每次new一个对象去读取。</li>
<li>网站的计数器，一般也是采用单例模式实现，否则难以同步。</li>
<li>应用程序的日志应用，一般都何用单例模式实现，这一般是由于共享的日志文件一直处于打开状态，因为只能有一个实例去操作，否则内容不好追加。</li>
<li>数据库连接池的设计一般也是采用单例模式，因为数据库连接是一种数据库资源。</li>
<li>操作系统的文件系统，也是大的单例模式实现的具体例子，一个操作系统只能有一个文件系统。</li>
<li>Application 也是单例的典型应用（Servlet编程中会涉及到）</li>
<li>在Spring中，每个Bean默认就是单例的，这样做的优点是Spring容器可以管理</li>
<li>在servlet编程中，每个Servlet也是单例</li>
<li>在spring MVC框架&#x2F;struts1框架中，控制器对象也是单例</li>
</ul>
<h4 id="单例模式的优点"><a href="#单例模式的优点" class="headerlink" title="单例模式的优点"></a>单例模式的优点</h4><ul>
<li>由于单例模式只生成一个实例，减少了系统性能开销，当一个对象的产生需要比较多的资源时，如读取配置、产生其他依赖对象时，则可以通过在应用启动时直接产生一个单例对象，然后永久驻留内存的方式来解决</li>
<li>单例模式可以在系统设置全局的访问点，优化环共享资源访问，例如可以设计一个单例类，负责所有数据表的映射处理</li>
</ul>
<h4 id="常见的五种单例模式实现方式："><a href="#常见的五种单例模式实现方式：" class="headerlink" title="常见的五种单例模式实现方式："></a>常见的五种单例模式实现方式：</h4><ul>
<li>主要：<ul>
<li>饿汉式（线程安全，调用效率高。 但是，不能延时加载。）</li>
<li>懒汉式（线程安全，调用效率不高。 但是，可以延时加载。）</li>
</ul>
</li>
<li>其他<ul>
<li>双重检测锁式（由于JVM底层内部模型原因，偶尔会出问题。不建议使用）</li>
<li>静态内部类式   (线程安全，调用效率高。 但是，可以延时加载)</li>
<li>枚举单例   (线程安全，调用效率高，不能延时加载，并且可以天然的防止反射和反序列化漏洞）</li>
</ul>
</li>
</ul>
<h4 id="如何选用"><a href="#如何选用" class="headerlink" title="如何选用?"></a>如何选用?</h4><ul>
<li><p>单例对象 占用 资源 少，不需要 延时加载：</p>
<p>​      枚举式 好于 饿汉式</p>
</li>
<li><p>单例对象 占用 资源 大，需要 延时加载：</p>
<p>​		静态内部类式 好于 懒汉式</p>
</li>
</ul>
<h4 id="饿汉式实现（单例对象立即加载）"><a href="#饿汉式实现（单例对象立即加载）" class="headerlink" title="饿汉式实现（单例对象立即加载）"></a>饿汉式实现（单例对象立即加载）</h4><pre class="language-java" data-language="java"><code class="language-java">public class SingletonDemo &#123;
	private static &#x2F;*final*&#x2F; SingletonDemo s &#x3D; new SingletonDemo02();
	private SingletonDemo02()&#123;&#125; &#x2F;&#x2F;私有化构造器
	public static &#x2F;*synchronized*&#x2F; SingletonDemo02 getInstance()&#123;
		return s;
	&#125;
&#125;

public class Client &#123;
    public static void main(String[] args) &#123;
        SingletonDemo s1 &#x3D; SingletonDemo.getInstance();
        SingletonDemo s2 &#x3D; SingletonDemo.getInstance();
        System.out.println(s1&#x3D;&#x3D;s2); &#x2F;&#x2F;结果为true
    &#125;
&#125;</code></pre>

<h5 id="点评："><a href="#点评：" class="headerlink" title="点评："></a>点评：</h5><ul>
<li>饿汉式单例模式代码中，static变量会在类装载时初始化，此时也不会涉及多个线程对象访问该对象的问<br>题。虚拟机保证只会装载一次该类，肯定不会发生并发访问的问题。因此，可以省略synchronized关键字。</li>
<li>问题：如果只是加载本类，而不是要调用getInstance()，甚至永远没有调用，则会造成资源浪费！</li>
</ul>
<h4 id="懒汉式实现（单例对象延迟加载）"><a href="#懒汉式实现（单例对象延迟加载）" class="headerlink" title="懒汉式实现（单例对象延迟加载）"></a>懒汉式实现（单例对象延迟加载）</h4><pre class="language-java" data-language="java"><code class="language-java">public class SingletonDemo01 &#123;
    private static SingletonDemo s;
    private SingletonDemo()&#123;&#125; &#x2F;&#x2F;私有化构造器
    public static synchronized SingletonDemo getInstance()&#123;
        if(s&#x3D;&#x3D;null)&#123;
       		s &#x3D; new SingletonDemo();
   		&#125;
    	return s;
    &#125;
&#125;</code></pre>

<h5 id="点评"><a href="#点评" class="headerlink" title="点评"></a>点评</h5><ul>
<li>要点：<br>lazy load! 延迟加载， 懒加载！ 真正用的时候才加载！</li>
<li>问题：<br>资源利用率高了。但是，每次调用getInstance()方法都要同步，并发效率较低。</li>
</ul>
<h4 id="双重检测锁实现"><a href="#双重检测锁实现" class="headerlink" title="双重检测锁实现"></a>双重检测锁实现</h4><pre class="language-java" data-language="java"><code class="language-java">public class SingletonDemo03 &#123;
    private static SingletonDemo03 instance &#x3D; null;
    
    public static SingletonDemo03 getInstance() &#123;
        if (instance &#x3D;&#x3D; null) &#123;
            SingletonDemo03 sc;
            synchronized (SingletonDemo03.class) &#123;
            	sc &#x3D; instance;
                if (sc &#x3D;&#x3D; null) &#123;
                    synchronized (SingletonDemo03.class) &#123;
                        if(sc &#x3D;&#x3D; null) &#123;
                            sc &#x3D; new SingletonDemo03();
                        &#125;
                    &#125;
                    instance &#x3D; sc;
                &#125;
            &#125;
        &#125;
        return instance;
    &#125;
    
    private SingletonDemo03() &#123;
    &#125;
&#125;</code></pre>

<h5 id="点评-1"><a href="#点评-1" class="headerlink" title="点评"></a>点评</h5><ul>
<li><p>这个模式将同步内容下方到if内部，提高了执行的效率不必每次获取对象时都进行同步，只有第一次才同步创建了以后就没必要了</p>
</li>
<li><p>问题：</p>
<p>由于编译器优化原因和JVM底层内部模型原因，偶尔会出问题。不建议使用。</p>
</li>
</ul>
<h4 id="静态内部类实现方式-也是一种懒加载方式）"><a href="#静态内部类实现方式-也是一种懒加载方式）" class="headerlink" title="静态内部类实现方式(也是一种懒加载方式）"></a>静态内部类实现方式(也是一种懒加载方式）</h4><pre class="language-java" data-language="java"><code class="language-java">public class SingletonDemo04 &#123;
    private static class SingletonClassInstance &#123;
    	private static final SingletonDemo04 instance &#x3D; new SingletonDemo04();
    &#125;
    
    public static SingletonDemo04 getInstance() &#123;
    	return SingletonClassInstance.instance;
    &#125;
    
    private SingletonDemo04() &#123;
    &#125;
&#125;</code></pre>

<h5 id="点评-2"><a href="#点评-2" class="headerlink" title="点评"></a>点评</h5><ul>
<li><p>要点</p>
<ul>
<li>外部类没有static属性，则不会像饿汉式那样立即加载对象。</li>
<li>只有真正调用getInstance(),才会加载静态内部类。加载类时是线程 安全的。 instance是static final<br>类型，保证了内存中只有这样一个实例存在，而且只能被赋值一次，从而保证了线程安全性.</li>
<li>兼备了并发高效调用和延迟加载的优势！</li>
</ul>
</li>
<li><p>问题：</p>
<ul>
<li><p>反射可以破解上面几种(不包含枚举式)实现方式！（可以在构造方法中手动抛出异常控制）</p>
</li>
<li><p>反序列化可以破解上面几种((不包含枚举式))实现方式！</p>
<ul>
<li><p>可以通过定义readResolve()防止获得不同对象</p>
</li>
<li><p>反序列化时，如果对象所在类定义了readResolve()，（实际是一种回调），<br>定义返回哪个对象。</p>
</li>
<li><p>&#96;&#96;&#96;java<br>public class SingletonDemo01 implements Serializable {<br>private static SingletonDemo01 s;<br>private SingletonDemo01() throws Exception{<br>    if(s!&#x3D;null){<br>        throw new Exception(“只能创建一个对象”);<br>        &#x2F;&#x2F;通过手动抛出异常，避免通过反射创建多个单例对象！<br>    }<br>} &#x2F;&#x2F;私有化构造器<br><br>public static synchronized SingletonDemo01 getInstance() throws Exception{<br>    if(s&#x3D;&#x3D;null){<br>        s &#x3D; new SingletonDemo01();<br>    }<br>    return s;<br>}<br><br>&#x2F;&#x2F;反序列化时，如果对象所在类定义了readResolve()，（实际是一种回调），定义返回哪个对象。<br>private Object readResolve() throws ObjectStreamException {<br>       return s;<br>}<br>}</p>
<pre class="language-none"><code class="language-none">
#### 使用枚举实现单例模式

&#96;&#96;&#96;java
public enum SingletonDemo05 &#123;
    &#x2F;**
    * 定义一个枚举的元素，它就代表了Singleton的一个实例。
    *&#x2F;
	INSTANCE;
    &#x2F;**
    * 单例可以有自己的操作
    *&#x2F;
    public void singletonOperation()&#123;
    	&#x2F;&#x2F;功能处理
    &#125;
&#125;

public static void main(String[] args) &#123;
    SingletonDemo05 sd &#x3D; SingletonDemo05.INSTANCE;
    SingletonDemo05 sd2 &#x3D; SingletonDemo05.INSTANCE;
    System.out.println(sd&#x3D;&#x3D;sd2);
&#125;</code></pre></li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="点评-3"><a href="#点评-3" class="headerlink" title="点评"></a>点评</h5><ul>
<li>优点：<ul>
<li>实现简单</li>
<li>枚举本身就是单例模式。由JVM从根本上提供保障！避免通过反射和反序列化的漏洞！</li>
</ul>
</li>
<li>缺点：<ul>
<li>无延迟加载</li>
</ul>
</li>
</ul>
<h4 id="常见的五种单例模式在多线程环境下的效率测试"><a href="#常见的五种单例模式在多线程环境下的效率测试" class="headerlink" title="常见的五种单例模式在多线程环境下的效率测试"></a>常见的五种单例模式在多线程环境下的效率测试</h4><p>大家只要关注相对值即可。在不同的环境下不同的程序测得值完全不一样</p>
<table>
<thead>
<tr>
<th>饿汉式</th>
<th>22ms</th>
</tr>
</thead>
<tbody><tr>
<td>静态内部类式</td>
<td>28ms</td>
</tr>
<tr>
<td>枚举式</td>
<td>32ms</td>
</tr>
<tr>
<td>双重检查锁式</td>
<td>65ms</td>
</tr>
<tr>
<td>懒汉式</td>
<td>636ms</td>
</tr>
</tbody></table>
<h5 id="CountDownLatch-（同步工具类）"><a href="#CountDownLatch-（同步工具类）" class="headerlink" title="CountDownLatch （同步工具类）"></a>CountDownLatch （同步工具类）</h5><p>同步辅助类，在完成一组正在其他线程中执行的操作之前，它允许一个或多个线程一直等待。</p>
<ul>
<li>countDown() 当前线程调此方法，则计数减一(建议放在 finally里执行)</li>
<li>await()， 调用此方法会一直阻塞当前线程，直到计时器的值为0</li>
</ul>
<h3 id="工厂模式-（包括抽象工厂）-Factory"><a href="#工厂模式-（包括抽象工厂）-Factory" class="headerlink" title="工厂模式 （包括抽象工厂） Factory"></a>工厂模式 （包括抽象工厂） Factory</h3><h4 id="作用："><a href="#作用：" class="headerlink" title="作用："></a>作用：</h4><p>实现了创建者和调用者的分离。</p>
<h4 id="核心本质"><a href="#核心本质" class="headerlink" title="核心本质"></a>核心本质</h4><ul>
<li>实例化对象，用工厂方法代替new操作。</li>
<li>将选择实现类、创建对象统一管理和控制。从而将调用者跟我们的实现类解耦。</li>
</ul>
<h4 id="详细分类："><a href="#详细分类：" class="headerlink" title="详细分类："></a>详细分类：</h4><ul>
<li><p>简单工厂模式(静态工厂模式)</p>
<p>用来生产同一等级结构中的任意产品。（对于增加新的产品，需要修改已有代码）</p>
<p>虽然某种程度不符合设计原则，但实际使用最多。</p>
</li>
<li><p>工厂方法模式</p>
<p>用来生产同一等级结构中的固定产品。（支持增加任意产品）</p>
<p>不修改已有类的前提下，通过增加新的工厂类实现扩展</p>
</li>
<li><p>抽象工厂模式</p>
<p>用来生产不同产品族的全部产品。（对于增加新的产品，无能为力；支持增加产品族）</p>
<p>不可以增加产品，可以增加产品族！</p>
</li>
</ul>
<h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><ul>
<li>DK中Calendar的getInstance方法</li>
<li>JDBC中Connection对象的获取</li>
<li>Hibernate中SessionFactory创建Session</li>
<li>spring中IOC容器创建管理bean对象</li>
<li>XML解析时的DocumentBuilderFactory创建解析器对象</li>
<li>反射中Class对象的newInstance()</li>
</ul>
<h4 id="面向对象设计的基本原则："><a href="#面向对象设计的基本原则：" class="headerlink" title="面向对象设计的基本原则："></a>面向对象设计的基本原则：</h4><ul>
<li>OCP（开闭原则，Open-Closed Principle）：一个软件的实体应当对扩展开放，对修改关闭。</li>
<li>DIP（依赖倒转原则，Dependence Inversion Principle）：要针对接口编程，不要针对实现编程。</li>
<li>LoD（迪米特法则，Law of Demeter）：只与你直接的朋友通信，而避免和陌生人通信。</li>
</ul>
<h4 id="不使用简单工厂的情况"><a href="#不使用简单工厂的情况" class="headerlink" title="不使用简单工厂的情况"></a>不使用简单工厂的情况</h4><pre class="language-java" data-language="java"><code class="language-java">interface Car&#123;
    void run();
&#125;
class Audi implements Car&#123;
    @override
    void run()&#123;
        sout&#x2F;&#x2F;
	&#125;
&#125;

class BaoMa implements Car&#123;
    @override
    void run()&#123;
        sout&#x2F;&#x2F;
	&#125;
&#125;

&#x2F;&#x2F;调用者
public class Client01 &#123; &#x2F;&#x2F;调用者
    public static void main(String[] args) &#123;
        Car c1 &#x3D; new Audi();
        Car c2 &#x3D; new Byd();
        c1.run();
        c2.run();
    &#125;
&#125;</code></pre>

<h4 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h4><pre class="language-none"><code class="language-none">public class CarFactory &#123;
    public static Car createCar(String type)&#123;
        Car c &#x3D; null;
        if(&quot;奥迪&quot;.equals(type))&#123;
        	c &#x3D; new Audi();
        &#125;else if(&quot;宝马&quot;.equals(type))&#123;
       		c &#x3D; new BaoMa();
        &#125;
        return c;
    &#125;
&#125;

public class CarFactory &#123;
    public static Car createAudi()&#123;
    	return new Audi();
    &#125;
    public static Car createBenz()&#123;
    	return new Benz();
    &#125;
&#125;
</code></pre>

<h5 id="点评-4"><a href="#点评-4" class="headerlink" title="点评"></a>点评</h5><ul>
<li>简单工厂模式也叫静态工厂模式，就是工厂类一般是使用静态方法，通过接收的参数的不同来返回不同的对象实例。</li>
<li>对于增加新产品无能为力！不修改代码的话，是无法扩展的。</li>
</ul>
<h4 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h4><pre class="language-java" data-language="java"><code class="language-java"></code></pre>

<h5 id="点评-5"><a href="#点评-5" class="headerlink" title="点评"></a>点评</h5><ul>
<li>为了避免简单工厂模式的缺点，不完全满足OCP。</li>
<li>工厂方法模式和简单工厂模式最大的不同在于，简单工厂模式只有一个（对于一个项目或者一个独立模块而言）工厂类，而工厂方法模式有一组实现了相同接口的工厂类</li>
</ul>
<h4 id="简单工厂模式和工厂方法模式PK"><a href="#简单工厂模式和工厂方法模式PK" class="headerlink" title="简单工厂模式和工厂方法模式PK:"></a>简单工厂模式和工厂方法模式PK:</h4><ul>
<li><p>结构复杂度</p>
<p>从这个角度比较，显然简单工厂模式要占优。简单工厂模式只需一个工厂类，而工厂方法模式的工厂类随着产品类个<br>数增加而增加，这无疑会使类的个数越来越多，从而增加了结构的复杂程度。</p>
</li>
<li><p>代码复杂度</p>
<p>代码复杂度和结构复杂度是一对矛盾，既然简单工厂模式在结构方面相对简洁，那么它在代码方面肯定是比工厂方法<br>模式复杂的了。简单工厂模式的工厂类随着产品类的增加需要增加很多方法（或代码），而工厂方法模式每个具体工<br>厂类只完成单一任务，代码简洁。</p>
</li>
<li><p>客户端编程难度</p>
<p>工厂方法模式虽然在工厂类结构中引入了接口从而满足了OCP，但是在客户端编码中需要对工厂类进行实例化。而简<br>单工厂模式的工厂类是个静态类，在客户端无需实例化，这无疑是个吸引人的优点。</p>
</li>
<li><p>管理上的难度</p>
<p>这是个关键的问题。<br>我们先谈扩展。众所周知，工厂方法模式完全满足OCP，即它有非常良好的扩展性。那是否就说明了简单工厂模式就<br>没有扩展性呢？答案是否定的。简单工厂模式同样具备良好的扩展性——扩展的时候仅需要修改少量的代码（修改工<br>厂类的代码）就可以满足扩展性的要求了。尽管这没有完全满足OCP，但我们不需要太拘泥于设计理论，要知道，<br>sun提供的java官方工具包中也有想到多没有满足OCP的例子啊。<br>然后我们从维护性的角度分析下。假如某个具体产品类需要进行一定的修改，很可能需要修改对应的工厂类。当同时<br>需要修改多个产品类的时候，对工厂类的修改会变得相当麻烦（对号入座已经是个问题了）。反而简单工厂没有这些<br>麻烦，当多个产品类需要修改是，简单工厂模式仍然仅仅需要修改唯一的工厂类（无论怎样都能改到满足要求吧？大<br>不了把这个类重写）</p>
</li>
<li><p>根据设计理论建议：工厂方法模式。但实际上，我们一般都用简单工厂模式。</p>
</li>
</ul>
<h4 id="抽象工厂模式-Abstract-Factory-Pattern"><a href="#抽象工厂模式-Abstract-Factory-Pattern" class="headerlink" title="抽象工厂模式 Abstract Factory Pattern"></a>抽象工厂模式 Abstract Factory Pattern</h4><h5 id="点评-6"><a href="#点评-6" class="headerlink" title="点评"></a>点评</h5><ul>
<li>来生产不同产品族的全部产品。（对于增加新的产品，无能为力；支持增加产品族）</li>
<li>抽象工厂模式是工厂方法模式的升级版本，在有多个业务品种、业务分类时，通过抽象工厂模式产生需要的对象是一种非常好的解决方式。</li>
</ul>
<h3 id="建造者模式-Builder-Pattern"><a href="#建造者模式-Builder-Pattern" class="headerlink" title="建造者模式 Builder Pattern"></a>建造者模式 Builder Pattern</h3><h4 id="核心本质-1"><a href="#核心本质-1" class="headerlink" title="核心本质"></a>核心本质</h4><ul>
<li>分离了对象子组件的单独构造(由Builder来负责)和装配(由Director负责)。 从而可以构造出复杂的对象。这个模式适用于：某个对象的构建过程复杂的情况下使用。</li>
<li>由于实现了构建和装配的解耦。不同的构建器，相同的装配，也可以做出不同的对象；<br>相同的构建器，不同的装配顺序也可以做出不同的对象。也就是实现了构建算法、装配<br>算法的解耦，实现了更好的复用。</li>
</ul>
<h4 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h4><p>1、我们要建造一个复杂的产品。比如：神州飞船,Iphone。这个复杂的产品的创建。有这样一个问题需要处理：<br>        装配这些子组件是不是有个步骤问题?<br>2、实际开发中，我们所需要的对象构建时，也非常复杂，有很多步骤需要处理时。</p>
<h4 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h4><ul>
<li>StringBuilder类的append方法</li>
<li>SQL中的PreparedStatement</li>
<li>JDOM中，DomBuilder、SAXBuilder</li>
</ul>
<h3 id="原型模式-prototype"><a href="#原型模式-prototype" class="headerlink" title="原型模式 prototype"></a>原型模式 prototype</h3><h4 id="场景："><a href="#场景：" class="headerlink" title="场景："></a>场景：</h4><p>思考一下：克隆技术是怎么样的过程? 克隆羊多利大家还记得吗?<br>javascript语言中的，继承怎么实现?那里面也有prototype，大家还记得吗?</p>
<h4 id="开发中的应用场景"><a href="#开发中的应用场景" class="headerlink" title="开发中的应用场景"></a>开发中的应用场景</h4><p>原型模式很少单独出现，一般是和工厂方法模式一起出现，通过clone的方法创建一个对象，然后由工厂方法提供给调用者。<br>spring中bean的创建实际就是两种：单例模式和原型模式。（当然，原型模式需要和工厂模式搭配起来）</p>
<h4 id="点评：-1"><a href="#点评：-1" class="headerlink" title="点评："></a>点评：</h4><ul>
<li>通过new产生一个对象需要非常繁琐的数据准备或访问权限，则可以使用原型模式。</li>
<li>就是java中的克隆技术，以某个对象为原型，复制出新的对象。显然，新的对象具备原型对象的特点</li>
<li>优势有：效率高(直接克隆，避免了重新执行构造过程步骤) 。</li>
<li>克隆类似于new，但是不同于new。new创建新的对象属性采用的是默认值。克隆出的对象的属性值完全和原型对象相同。并且克隆出的新对象改变不会影响原型对象。然后，再修改克隆对象的值。</li>
</ul>
<h4 id="原型模式实现："><a href="#原型模式实现：" class="headerlink" title="原型模式实现："></a>原型模式实现：</h4><ul>
<li>Cloneable接口和clone方法</li>
<li>Prototype模式中实现起来最困难的地方就是内存复制操作，所幸在Java中提供了 clone()方法替我们做了绝大部分事情</li>
<li>&#x3D;&#x3D;克隆和拷贝一回事！&#x3D;&#x3D;</li>
</ul>
<h4 id="浅克隆存在的问题"><a href="#浅克隆存在的问题" class="headerlink" title="浅克隆存在的问题"></a>浅克隆存在的问题</h4><p>被复制的对象的所有变量都含有与原来的对象相同的值，而所有的对其他对象的引用都仍然指向原来的对象。</p>
<h4 id="深克隆如何实现"><a href="#深克隆如何实现" class="headerlink" title="深克隆如何实现?"></a>深克隆如何实现?</h4><ul>
<li>深克隆把引用的变量指向复制过的新对象，而不是原有的被引用的对象。</li>
<li>深克隆：让已实现Clonable接口的类中的属性也实现Clonable接口</li>
<li>基本数据类型和String能够自动实现深度克隆（值的复制）</li>
</ul>
<h5 id="利用序列化和反序列化技术实现深克隆！"><a href="#利用序列化和反序列化技术实现深克隆！" class="headerlink" title="利用序列化和反序列化技术实现深克隆！"></a>利用序列化和反序列化技术实现深克隆！</h5><pre class="language-java" data-language="java"><code class="language-java">Date date &#x3D; new Date(12312321331L);
Sheep s1 &#x3D; new Sheep(&quot;少利&quot;,date);
System.out.println(s1);
System.out.println(s1.getSname());
System.out.println(s1.getBirthday());

&#x2F;&#x2F;使用序列化和反序列化实现深复制
ByteArrayOutputStream bos &#x3D; new ByteArrayOutputStream();
ObjectOutputStream oos &#x3D; new ObjectOutputStream(bos);
oos.writeObject(s1);
byte[] bytes &#x3D; bos.toByteArray();

ByteArrayInputStream bis &#x3D; new ByteArrayInputStream(bytes);
ObjectInputStream ois &#x3D; new ObjectInputStream(bis);
Sheep s2 &#x3D; (Sheep) ois.readObject(); &#x2F;&#x2F;克隆好的对象！

System.out.println(&quot;修改原型对象的属性值&quot;);
date.setTime(23432432423L);
System.out.println(s1.getBirthday());
s2.setSname(&quot;多利&quot;);
System.out.println(s2);
System.out.println(s2.getSname());
System.out.println(s2.getBirthday())</code></pre>



<h3 id="创建型模式总结"><a href="#创建型模式总结" class="headerlink" title="创建型模式总结"></a>创建型模式总结</h3><ul>
<li><p>单例模式</p>
<p>保证一个类只有一个实例，并且提供一个访问该实例的全局访问点。</p>
<ul>
<li>主要：<ul>
<li>饿汉式（线程安全，调用效率高。 但是，不能延时加载。）</li>
<li>懒汉式（线程安全，调用效率不高。 但是，可以延时加载。）</li>
</ul>
</li>
<li>其他<ul>
<li>双重检测锁式（由于JVM底层内部模型原因，偶尔会出问题。不建议使用）</li>
<li>静态内部类式   (线程安全，调用效率高。 但是，可以延时加载)</li>
<li>枚举单例   (线程安全，调用效率高，不能延时加载，并且可以天然的防止反射和反序列化漏洞）</li>
</ul>
</li>
</ul>
</li>
<li><p>工厂模式</p>
<ul>
<li>简单工厂模式<br> 用来生产同一等级结构中的任意产品。（对于增加新的产品，需要修改已有代码）</li>
<li>工厂方法模式<br>  用来生产同一等级结构中的固定产品。（支持增加任意产品）</li>
<li>抽象工厂模式<br>  用来生产不同产品族的全部产品。（对于增加新的产品，无能为力；支持增加产品族）</li>
</ul>
</li>
<li><p>建造者模式<br> 分离了对象子组件的单独构造(由Builder来负责)和装配(由Director负责)。 从而可 以构造出复杂的对象。</p>
</li>
<li><p>原型模式<br>  通过new产生一个对象需要非常繁琐的数据准备或访问权限，则可以使用原型模式</p>
</li>
</ul>
</div><div id="reward-container"><span class="hty-icon-button button-glow" id="reward-button" title="打赏" onclick="var qr = document.getElementById(&quot;qr&quot;); qr.style.display = (qr.style.display === &quot;none&quot;) ? &quot;block&quot; : &quot;none&quot;;"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-hand-coin-line"></use></svg></span><div id="reward-comment">I'm so cute. Please give me money.</div><div id="qr" style="display:none;"><div style="display:inline-block"></div><div style="display:inline-block"></div><div style="display:inline-block"></div></div></div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者：</strong>冰不良</li><li class="post-copyright-link"><strong>本文链接：</strong><a href="https://bingbuliang.github.io/2021/04/01/java-designer-mode-1/" title="设计者模式——1 创建模型概述篇">https://bingbuliang.github.io/2021/04/01/java-designer-mode-1/</a></li><li class="post-copyright-license"><strong>版权声明：</strong>本博客所有文章除特别声明外，均默认采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="noopener" title="CC BY-NC-SA 4.0 "><svg class="icon"><use xlink:href="#icon-creative-commons-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-by-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-nc-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-sa-line"></use></svg></a> 许可协议。</li></ul></section></article><div class="post-nav"><div class="post-nav-item"><a class="post-nav-prev" href="/2021/04/02/java-designer-mode-2/" rel="prev" title="设计者模式——2 结构型模式概述篇"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-left-s-line"></use></svg><span class="post-nav-text">设计者模式——2 结构型模式概述篇</span></a></div><div class="post-nav-item"><a class="post-nav-next" href="/2021/03/13/python-spider-xuexi/" rel="next" title="抓取学习**的题目"><span class="post-nav-text">抓取学习**的题目</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-right-s-line"></use></svg></a></div></div></div><div id="comment"><div class="comment-tooltip text-center"><span>若您无 GitHub 账号，可直接在下方匿名评论。</span><br><span>若您想及时得到回复提醒，建议跳转 GitHub Issues 评论。</span><br><span>若没有本文 Issue，您可以使用 Comment 模版新建。</span><br><a class="hty-button hty-button--raised" id="github-issues" target="_blank" rel="noopener" href="https://github.com/BingBuLiang/BingBuLiang.github.io/issues?q=is:issue+设计者模式——1 创建模型概述篇">GitHub Issues</a></div></div></main><footer class="sidebar-translate" id="footer"><div class="beian"><a rel="noopener" href="https://www.beian.miit.gov.cn" target="_blank"></a></div><div class="copyright"><span>&copy; Sun Feb 02 2020 08:00:00 GMT+0800 (中国标准时间) – 2023 </span><span class="with-love" id="animate"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-cloud-line"></use></svg></span><span class="author"> 冰不良</span></div><div class="powered"><span>由 <a href="https://hexo.io" target="_blank" rel="noopener">Hexo</a> 驱动 v6.3.0</span><span class="footer-separator">|</span><span>主题 - <a rel="noopener" href="https://github.com/YunYouJun/hexo-theme-yun" target="_blank"><span>Yun</span></a> v0.7.1</span></div><div class="live_time"><span>本博客已萌萌哒地运行</span><span id="display_live_time"></span><span class="moe-text">(●'◡'●)</span><script>function blog_live_time() {
  window.setTimeout(blog_live_time, 1000);
  const start = new Date('2020-02-02T00:00:00');
  const now = new Date();
  const timeDiff = (now.getTime() - start.getTime());
  const msPerMinute = 60 * 1000;
  const msPerHour = 60 * msPerMinute;
  const msPerDay = 24 * msPerHour;
  const passDay = Math.floor(timeDiff / msPerDay);
  const passHour = Math.floor((timeDiff % msPerDay) / 60 / 60 / 1000);
  const passMinute = Math.floor((timeDiff % msPerHour) / 60 / 1000);
  const passSecond = Math.floor((timeDiff % msPerMinute) / 1000);
  display_live_time.innerHTML = " " + passDay + " 天 " + passHour + " 小时 " + passMinute + " 分 " + passSecond + " 秒";
}
blog_live_time();
</script></div></footer><a class="hty-icon-button" id="goUp" aria-label="back-to-top" href="#"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-up-s-line"></use></svg><svg class="progress-circle-container" viewBox="0 0 100 100"><circle class="progress-circle" id="progressCircle" cx="50" cy="50" r="48" fill="none" stroke="#6200ee" stroke-width="2" stroke-linecap="round"></circle></svg></a><a class="popup-trigger hty-icon-button icon-search" id="search" href="javascript:;" title="搜索"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-search-line"></use></svg></span></a><script defer src="/js/search/index.js"></script><script defer src="https://cdn.jsdelivr.net/npm/algoliasearch@4/dist/algoliasearch-lite.umd.js"></script><script defer src="https://cdn.jsdelivr.net/npm/instantsearch.js@4/dist/instantsearch.production.min.js"></script><script defer src="/js/search/algolia-search.js"></script><div class="popup search-popup"><div class="search-header"><span class="popup-btn-close close-icon hty-icon-button"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-close-line"></use></svg></span></div><div class="search-input-container"></div><div class="algolia-results"><div id="algolia-stats"></div><div id="algolia-hits"></div><div class="algolia-pagination" id="algolia-pagination"></div></div></div><script>let date = new Date();
let today = (date.getMonth() + 1) + "-" + date.getDate()
if ("4-4".indexOf(today) !== -1) {
  document.documentElement.style.filter = "grayscale(1)";
}</script></div><script defer src="/js/hexo-theme-yun.js"></script></body></html>